% !TEX root = ../Thesis.tex

\chapter{Polimorfismo}
Il polimorfismo è un concetto fondamentale della programmazione. Derivato dal greco “molte forme”, il polimorfismo consente a entità di assumere diverse forme o comportamenti in base al contesto, permettendo di scrivere codice più flessibile, estendibile e manutenibile. Grazie al polimorfismo, è possibile utilizzare un'interfaccia comune per manipolare elementi di tipi diversi, facilitando così l'implementazione di soluzioni generiche. Il vantaggio principale del polimorfismo è il miglioramento della qualità del codice:
\begin{itemize}
    \item Favorisce l'astrazione, consentendo di trattare oggetti di tipi diversi in modo uniforme.
    \item Riduce la duplicazione di codice, poiché le operazioni comuni possono essere definite una sola volta e riutilizzate per diversi tipi.
    \item Semplifica la gestione delle estensioni future, poiché nuove funzionalità possono essere aggiunte senza modificare il codice esistente.
\end{itemize}
In un linguaggio come Java, orientato agli oggetti, il polimorfismo è una caratteristica centrale e largamente supportata tramite ereditarietà e interfacce. Rust, pur non essendo un linguaggio tradizionalmente orientato agli oggetti, offre un approccio alternativo al polimorfismo, basato su trait e tipi generici, che permette di ottenere astrazione e flessibilità.

In questo capitolo verrà fornita una panoramica delle modalità con cui Java e Rust implementano e sfruttano il polimorfismo, confrontando i due linguaggi.

\section{Polimorfismo in Java}
Java supporta il polimorfismo attraverso due principali meccanismi: il \textit{subtyping} (polimorfismo per inclusione) e il \textit{parametric polymorphism} (polimorfismo parametrico). 

Il subtyping si basa sul fatto che ci possa essere una relazione tra tipi chiamata \textit{relazione di sottotipo}. Si dice che un tipo \textit{A} è un sottotipo di un tipo \textit{B} quando il contesto richiede un elemento di tipo \textit{B} ma può accettare un elemento di tipo \textit{A}. In Java, la relazione di sottotipo viene implementata attraverso l'ereditarietà e le interfacce. Le classi possono estendere altre classi e implementare interfacce, consentendo agli oggetti di essere trattati come istanze della loro classe base o interfaccia. 

Il parametric polymorphism permette di assegnare a una parte di codice un tipo generico, utilizzando variabili di tipo al posto di tipi specifici, che poi possono essere istanziate con tipi concreti al momento dell'utilizzo.
\section{Polimorfismo in Rust}
In Rust, il polimorfismo è implementato attraverso i concetti di \textit{trait} e i \textit{generics}. I trait sono simili alle interfacce in Java e definiscono un insieme di metodi che un tipo deve implementare per essere considerato conforme a quel trait. I generics consentono di scrivere funzioni e strutture dati che possono operare su tipi diversi senza dover specificare un tipo concreto. Tramite l'uso dei generics si ottiene il \textit{parametric polymorphism}, come in Java, mentre attraverso i trait si ottiene il \textit{bounded parametric polymorphism}, che consente di specificare vincoli sui tipi generici.
\section{Generics: Monomorphization e Type Erasure}
\label{sec:generics}
Sia Rust che Java supportano la programmazione generica, che consente di scrivere codice che può operare su tipi diversi senza dover duplicare il codice per ogni tipo specifico. La sintassi per definire i generics in Rust e Java è simile, utilizzando parentesi angolare per specificare i parametri di tipo. Tuttavia, ci sono differenze significative nella gestione dei generics tra i due linguaggi.

Il compilatore Java utilizza un processo chiamato \textit{type erasure} per implementare i generics, questo include i seguenti fatti:
\begin{itemize}
    \item Durante la compilazione i parametri di tipo vengono sostituiti con il tipo \texttt{Object} o con un tipo specifico se è stato definito un vincolo sul parametro di tipo.
    \item Vengono inseriti cast espliciti per mantenere la type safety.
    \item Genera \textit{Bridge Methods} per preservare il polimorfismo dopo il processo di type erasure.
\end{itemize}
Ad esempio:
\begin{minted} [fontsize=\small] {Java}
    public class GenericClass<T> {
        T value;

        void setValue(T value) { 
            this.value = value;
        }
    }
\end{minted}
Dopo la type erasure, il codice diventa:
\begin{minted} [fontsize=\small] {Java}
    public class GenericClass {
        Object value;

        void setValue(Object value) { 
            this.value = value;
        }
    }
\end{minted}
Nel caso in cui, invece, si definisca un vincolo di tipo, ad esempio \texttt{<T extends Number>}, il compilatore Java sostituirà \texttt{T} con \texttt{Number} durante la type erasure, mantenendo la type safety:
\begin{minted} [fontsize=\small] {Java}
    public class GenericClass{
        Number value;

        void setValue(Number value) { 
            this.value = value;
        }
    }
\end{minted}
Quando si combina la type erasure con l'overriding dei metodi, Java genera dei \textit{Bridge Methods} per garantire che il polimorfismo funzioni correttamente. Uno scenario tipico è il seguente:
\begin{itemize}
    \item Una classe generica o un'interfaccia ha un metodo che usa un tipo generico. 
    \item Una sua sottoclasse sovrascrive quel metodo con un tipo concreto. 
    \item Dopo la type erasure, le firme dei due metodi non corrispondono più. Questo romperebbe il polimorfismo. 
\end{itemize}
Ad esempio: 
\begin{minted} [fontsize=\small] {Java}
    class Parent<T> {
        T getValue() { return null; }
    }

    class Child extends Parent<String> {
        @Override
        String getValue() {
             return "Hello"; 
        }
    }
\end{minted}
Dopo la type erasure:
\begin{minted} [fontsize=\small] {Java}
    class Parent {
        Object getValue() {
            return null; 
        }
    }

    class Child extends Parent {
        String getValue() {
            return "Hello"; 
        }

        // Bridge method generato dal compilatore:
        // Garantisce che la chiamata a Parent.getValue() 
        // funzioni correttamente
        Object getValue() {
            return this.getValue(); // chiama String getValue()
        }
    }
\end{minted}
In Rust, invece, i generics sono implementati tramite un processo chiamato \textit{monomorphization}. Questo è il processo tramite il cui il compilatore Rust genera codice specifico per ogni tipo concreto utilizzato con i generics. Questo significa che Rust sostituisce i parametri di tipo generici con i tipi concreti utilizzati, e genera una versione specifica della funzione o della struttura per ogni tipo. Ad esempio: 
\begin{minted} [fontsize=\small] {Rust}
    struct Boxed<T> {
        value: T,
    }

    fn main() {
        let a = Boxed { value: 123 }; // T = i32
        let b = Boxed { value: "text" }; // T = &str
    }
\end{minted}
Dopo la monomorphization, il compilatore Rust genera due versioni della struttura \texttt{Boxed}:
\begin{minted} [fontsize=\small] {Rust}
    struct Boxed_i32 {
        value: i32,
    }

    struct Boxed_str {
        value: &str,
    }
\end{minted}
È facile notare come i due approcci siano molto diversi e abbiano implicazioni diverse sul modo in cui il codice viene generato e sulla performance:
\begin{itemize}
    \item Rispetto alla type erasure di Java, la monomorphization di Rust porta diversi vantaggi in termini di performance:
    \begin{itemize}
        \item Nella type erasure, poiché i parametri di tipo vengono eliminati, il compilatore spesso deve inserire cast espliciti per garantire la type safety, il che può introdurre un overhead. Questo overhead è spesso trascurabile ma comunque presente. 
        \item I generics di Java non possono essere utilizzati con tipi primitivi, come \texttt{int} o \texttt{double}, ma solo con oggetti. Questo significa che quando si usano generics con tipi primitivi, Java deve utilizzare il boxing e l'unboxing, che introducono un ulteriore overhead.
        \item Poiché Java usa lo stesso bytecode per tutte le istanziazioni di un generico, non può ottimizzare il codice per tipi specifici. Questo può essere rilevante per sistemi che richiedono un alto grado di performance.
        \item Il monomorphization è un meccanismo statico che risolve i tipi al momento della compilazione, quindi non ha overhead a runtime. Invece, la type erasure può coinvolgere il dynamic dispatch di Java che può essere più costoso in termini di performance.
    \end{itemize}
    \item La monomorphization può portare ad un aumento della dimensione del codice del programma compilato poiché vengono generate diverse versioni della stessa funzione generica, una per ogni combinazione di tipi con cui viene chiamata. 
    \item La monomorphization può incrementare notevolmente il tempo di compilazione del programma, specialmente se ci sono molte combinazioni di tipi concreti con cui viene chiamata una funzione generica.
    \item La monomorphization può fornire messaggi di errore più chiari e specifici poiché ogni versione specifica della funzione generica ha tipi concreti associati.
\end{itemize}
\section{Rust Traits}
\label{sec:rust_traits}
Un \textit{trait} è un costrutto di Rust che consente di definire un insieme di funzionalità che un tipo deve implementare. I traits vengono utilizzati, quindi, per definire comportamenti comuni che possono essere condivisi tra diversi tipi. Un trait viene dichiarato utilizzando la keyword \texttt{trait} come segue:
\begin{minted} [fontsize=\small] {Rust}
    pub trait MyTrait {
        fn my_method(&self) -> String;
    }
\end{minted}
L'implementazione del trait avviene attraverso le keywords \texttt{impl} e \texttt{for} come segue:
\begin{minted} [fontsize=\small] {Rust}
    struct MyStruct;

    impl MyTrait for MyStruct {
        fn my_method(&self) -> () {
            println!("Hello from MyStruct");
        }
    }
\end{minted}
I traits possono essere utilizzati per realizzare il bounded parametric polymorphism in Rust, consentendo di specificare vincoli sui tipi generici (\textit{trait bounds}). Ad esempio, si può definire una funzione che accetta un tipo generico che implementa un determinato trait nel seguente modo:
\begin{minted} [fontsize=\small] {Rust}
    fn my_function<T: MyTrait>(item: T) {
        println!("{}", item.my_method());
    }
\end{minted}
Nel caso in cui siano presenti più vincoli, questi possono essere combinati utilizzando il simbolo \texttt{+} oppure attraverso l'uso di \texttt{where}:
\begin{minted} [fontsize=\small] {Rust}
    fn my_function<T>(item: T)
    where 
        T: MyTrait + AnotherTrait 
    {
        println!("{}", item.my_method());
    }   
\end{minted}
In Java, è possibile ottenere un comportamento simile ai trait bounds attraverso i vincoli di tipo (\textit{type bounds}) nelle dichiarazioni generiche. Ad esempio, si può definire una classe generica che accetta un tipo che estende una classe base o implementa un'interfaccia:
\begin{minted} [fontsize=\small] {Java}
    public class MyClass<T extends Bound> {
        /* ... */
    }
\end{minted}
In questo esempio, \texttt{T} è un tipo generico che deve implementare l'interfaccia \texttt{MyInterface}. Questo consente di utilizzare i metodi definiti nell'interfaccia \texttt{MyInterface} all'interno della classe \texttt{MyClass}. Anche in Java è possibile definire più vincoli di tipo attraverso l'utilizzo dell'operatore \texttt{\&}:
\begin{minted} [fontsize=\small] {Java}
    public class MyClass<T extends Bound & AnotherBound> {
        /* ... */ 
    }
\end{minted}
Si può facilmente notare come il concetto di trait in Rust sia molto simile alle interfacce in Java. Entrambi servono entrambi a garantire che un valore o un oggetto possa essere utilizzato secondo un certo protocollo o insieme di regole, permettendo diverse implementazioni concrete senza essere vincolati a dettagli di implementazione, a differenza di quanto accade con una superclasse Java. Tuttavia, sono presenti alcune differenze significative:
\begin{itemize}
    \item In Rust, un trait non è un tipo concreto, ma un insieme di metodi che un tipo può implementare. In Java, invece, un' interfaccia funge sia da contratto sia da tipo: quando una classe implementa un'interfaccia, è possibile trattare gli oggetti di quella classe come istanze del tipo dell'interfaccia stessa. La differenza principale è quindi che in Rust il trait è separato dal tipo concreto, mentre in Java l'interfaccia può essere usata direttamente come tipo del riferimento.
    \item In Java, le interfacce richiedono che la classe che le implementa abbia metodi con nomi specifici. Questo può creare conflitti: ad esempio, due interfacce potrebbero essere impossibili da implementare insieme se hanno metodi con lo stesso nome ma tipi di ritorno diversi. Ad esempio:
    \begin{minted} [fontsize=\small] {Java}
        public interface InterfaceA {
            String getValue();
        }

        public interface InterfaceB {
            int getValue();
        }

        public class MyClass implements InterfaceA, InterfaceB {
            // Errore: il compilatore non sa quale
            // metodo getValue() implementare
        }
    \end{minted}
    In Rust, invece, ogni trait ha il proprio namespace separato. Quando si implementa un trait per un tipo, lo si fa in un blocco \texttt{impl} separato specificando il trait. In questo modo è sempre esplicito a quale trait appartiene ogni metodo, evitando conflitti tra trait diversi. Nel caso in cui  entrambi i trait sono nello scope è necessario specificare il trait usando la sintassi \texttt{Trait::method(\&obj)} invece della semplice chiamata con la notazione puntata.
    \item In Java, le interfacce possono avere parametri di tipo. Tuttavia, un oggetto può implementare un'interfaccia generica solo una volta:
    \begin{minted} [fontsize=\small] {Java}
        public interface anInterface<T> {
            void doSomething(T value);
        }

        public class MyClass implements anInterface<String>
                                        anInterface<Integer>
        {
            @Override
            public void doSomething(String value) { /* ... */ }
            //Errore: il compilatore non sa quale metodo 
            // doSomething() implementare
        }        
    \end{minted}
    In Rust, invece, un trait può essere implementato per molti tipi diversi, e ciascuna implementazione è considerata sostanzialmente un trait distinto:
    \begin{minted} [fontsize=\small] {Rust}
        trait MyTrait<T> {
            fn do_something(&self, value: T);
        }

        struct MyStruct;

        impl MyTrait<String> for MyStruct {
            fn do_something(&self, value: String) { /* ... */ }
        }

        impl MyTrait<i32> for MyStruct {
            fn do_something(&self, value: i32) { /* ... */ }
        }
    \end{minted}
    \item In Rust, esiste la cosiddetta \textit{Orphan Rule}: si può implementare un trait per un tipo solo se almeno uno dei due (trait o tipo) è definito nel proprio crate \footnote{Un crate è un pacchetto di codice Rust.}. Quindi se il trait è definito nel proprio crate, si può implementare per tipi definiti altrove, ad esempio \textit{String} o \textit{i32}. In Java, invece, non è possibile aggiungere un'interfaccia a un tipo già definito senza modificarne la classe. Quindi non si può implementare un'interfaccia di un tipo su cui non si ha accesso al codice sorgente. Per ottenere un comportamento simile a Rust, si possono utilizzare tecniche come l'utilizzo di classi \textit{Wrapper}:
    \begin{minted} [fontsize=\small] {Java}
        public interface MyInterface {
            void doSomething();
        }

        public class MyWrapper implements MyInterface {
            private final String value;

            public MyWrapper(String value) {
                this.value = value;
            }

            @Override
            public void doSomething() { /* ... */ }
        }
    \end{minted}
\end{itemize}
\section{Static Dispatch e Dynamic Dispatch}
Quando il codice coinvolge il polimorfismo, sono necessari meccanismi per determinare quale versione specifica sta venendo effettivamente eseguita. Questo processo prende il nome di \textit{Dispatch}. Esistono due forme di dispatch: lo \textit{static dispatch} e il \textit{dynamic dispatch}. 

Tramite lo static dispatch la decisione su quale versione specifica utilizzare viene risolta al momento della compilazione e, quindi, non c'è alcun overhead a runtime per determinare uale implementazione utilizzare. In Rust, questo avviene attraverso i \textit{generics} e i \textit{trait bounds}. Quando si utilizza un tipo generico con un trait bound, il compilatore genera una versione specializzata della funzione per ogni tipo concreto utilizzato. Questo processo è noto come \textit{monomorphization} (descritto in dettaglio nella Sezione \ref{sec:generics}). In Java, invece, lo static dispatch si applica a:
\begin{itemize}
    \item \textit{Method overloading}: la versione del metodo chiamato è determinata al compile-time in base ai tipi dichiarati dei parametri.
\end{itemize}
